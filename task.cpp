#include <iostream> // Для std::cout та std::cin (ввід/вивід в консоль)
#include <limits>   // Для std::numeric_limits (використовується для очистки буфера вводу у функціях нижче)
#include <string>   // Для роботи з відступами (використовується в Tree::draw) та для передачі імені дерева у запит висоти

// --- БАЗОВИЙ КЛАС: Загальне поняття "Дерево" ---
// Це АБСТРАКТНИЙ базовий клас. Він описує, ЩО таке дерево і ЩО воно вміє робити
// в загальному, але не визначає *всіх* деталей. Не можна створити об'єкт
// типу просто "Tree" (не можна написати Tree myTree(5);).
// Він слугує як "шаблон" або "інтерфейс" для всіх конкретних типів дерев.
class Tree {
// protected: секція означає, що ці члени класу (поля та методи)
// доступні всередині самого класу Tree ТА всередині всіх його класів-нащадків
// (SpruceTree, PineTree, OakTree), але НЕ доступні напряму ззовні (наприклад, з main).
protected:
    // --- Поля класу (Member Variables / Fields) ---
    // Поле - це змінна, яка належить кожному об'єкту класу.

    int height; // Зберігає висоту дерева (кількість шарів крони).
                // Кожен конкретний об'єкт дерева (ялинка, сосна...) матиме свою висоту.

    // --- Методи класу (Member Functions / Methods) ---
    // Метод - це функція, яка належить класу і зазвичай працює з його полями.

    // ЧИСТО ВІРТУАЛЬНИЙ МЕТОД (Pure Virtual Function) `= 0`
    // Оголошує "контракт": КОЖЕН *конкретний* клас-нащадок (НЕ абстрактний)
    // ЗОБОВ'ЯЗАНИЙ надати свою реалізацію цього методу.
    // Сам клас Tree не знає, яким символом заповнювати дерево, це знають лише нащадки.
    // `virtual` - ключове слово для поліморфізму (дозволяє викликати правильну версію методу через вказівник на базовий клас).
    // `const` - обіцянка, що цей метод не змінює стан об'єкта (не змінює значення полів, наприклад `height`).
    virtual char getFillCharacter() const = 0;

    // ВІРТУАЛЬНИЙ МЕТОД (Virtual Function) - НЕ чистий (має реалізацію за замовчуванням)
    // Надає базову реалізацію для малювання стовбура.
    // `virtual` дозволяє класам-нащадкам, *за бажанням*, перевизначити (override)
    // цей метод, якщо їм потрібна інша логіка малювання стовбура. Якщо не перевизначать - буде використана ця версія.
    // `protected` - зазвичай викликається з інших методів класу (як тут з `draw`) або з методів нащадків.
    // `const` - обіцянка не змінювати об'єкт.
    virtual void drawTrunk() const {
        // Робимо відступ, щоб стовбур був приблизно по центру крони
        for (int i = 0; i < height - 1; ++i) {
            std::cout << " ";
        }
        // Малюємо сам стовбур (просто два символи '#')
        if (height > 0) { // Додаткова перевірка, хоча висота має бути > 0
             std::cout << "##\n";
        }
    }

// public: секція означає, що ці члени класу доступні з будь-якого місця програми,
// де є доступ до об'єкта цього класу (або вказівника/посилання на нього).
public:
    // --- Конструктор ---
    // Спеціальний метод, який викликається автоматично при створенні об'єкта класу (`new Tree(...)`).
    // Його завдання - ініціалізувати початковий стан об'єкта (встановити значення полів).
    // `explicit` - забороняє неявні (випадкові) перетворення типів до типу Tree. Рекомендовано для конструкторів з одним параметром.
    explicit Tree(int h) : height(h) { // `:` - початок списку ініціалізації членів. `height(h)` - ініціалізуємо поле `height` значенням параметру `h`. Це ефективніше, ніж присвоєння в тілі конструктора.
        // Додаткова перевірка в тілі конструктора: якщо передали некоректну висоту, встановимо мінімально допустиму.
        if (height < 1) {
             height = 1;
        }
    }

    // --- ВІРТУАЛЬНИЙ ДЕСТРУКТОР ---
    // Дуже ВАЖЛИВО для базових класів у поліморфних ієрархіях!
    // Деструктор - спеціальний метод, що викликається автоматично перед знищенням
    // об'єкта (наприклад, при використанні `delete`).
    // `virtual` тут гарантує, що при видаленні об'єкта через вказівник на БАЗОВИЙ клас (`Tree* ptr = new SpruceTree(5); delete ptr;`),
    // спочатку буде викликаний деструктор КОНКРЕТНОГО класу (`~SpruceTree()`),
    // а ПОТІМ деструктор базового класу (`~Tree()`). Це забезпечує правильне звільнення всіх ресурсів.
    // Якщо деструктор базового класу НЕ віртуальний, то при `delete ptr` викличеться ТІЛЬКИ `~Tree()`,
    // що може призвести до витоків пам'яті або некоректного завершення роботи, якщо нащадок мав що прибирати.
    // Тут тіло деструктора порожнє, бо нам немає що специфічно прибирати в базовому класі, але він МАЄ бути віртуальним.
    virtual ~Tree() {}

    // --- Основний метод малювання ---
    // `virtual` - дозволяє нащадкам повністю перевизначити логіку малювання, якщо базова не підходить (хоча в цьому прикладі вони цього не роблять).
    // `const` - малювання не змінює саме дерево (його висоту чи тип).
    // Цей метод використовує інші методи класу (`getFillCharacter`, `drawTrunk`) для виконання своєї роботи.
    virtual void draw() const {
        if (height <= 0) return; // Перевірка перед малюванням

        // Цикл по шарах крони
        for (int layer = 0; layer < height; ++layer) {
            // Розрахунок і друк відступу
            int spaces = height - 1 - layer;
            for (int i = 0; i < spaces; ++i) {
                std::cout << " ";
            }
            // Друк лівої частини гілки
            std::cout << "/";

            // --- МАГІЯ ПОЛІМОРФІЗМУ САМЕ ТУТ ---
            // Викликаємо getFillCharacter(). Хоча ми в методі класу Tree,
            // завдяки `virtual` буде викликана та версія getFillCharacter(),
            // яка реалізована в *конкретному* об'єкті, на який вказує вказівник
            // (SpruceTree::getFillCharacter, PineTree::getFillCharacter і т.д.).
            char fillChar = getFillCharacter(); // Отримуємо символ від *конкретного* дерева

            // Розрахунок і друк внутрішнього заповнення
            int innerWidth = 2 * layer;
            for (int i = 0; i < innerWidth; ++i) {
                std::cout << fillChar;
            }
            // Друк правої частини гілки і перехід на новий рядок
            std::cout << "\\\n";
        }
        // Після малювання крони викликаємо метод для малювання стовбура.
        // Знову ж таки, якщо якийсь нащадок перевизначить drawTrunk, буде викликана його версія.
        drawTrunk();
    }

    // --- Метод-геттер (Getter) ---
    // Надає безпечний спосіб отримати значення приватного або захищеного поля ззовні класу.
    // `const` - отримання висоти не змінює об'єкт.
    int getHeight() const { return height; }
}; // Кінець опису класу Tree


// --- КОНКРЕТНИЙ КЛАС-НАЩАДОК: Ялинка ---
// `: public Tree` - це синтаксис УСПАДКУВАННЯ.
// Означає, що клас `SpruceTree` "є різновидом" (`is-a`) класу `Tree`.
// Він автоматично отримує (успадковує) всі `public` та `protected` поля і методи
// від класу `Tree` (включаючи `height`, `drawTrunk`, `draw`, `getHeight`, віртуальний деструктор).
// `public` перед `Tree` означає, що успадковані `public` члени залишаються `public`,
// а `protected` залишаються `protected`.
class SpruceTree : public Tree {
public:
    // --- Конструктор Нащадка ---
    // Приймає висоту `h`.
    // `: Tree(h)` - ВАЖЛИВО: викликає конструктор БАЗОВОГО класу (`Tree`),
    // передаючи йому отриману висоту `h`. Це необхідно для ініціалізації
    // успадкованої частини об'єкта (поля `height`).
    explicit SpruceTree(int h) : Tree(h) {}

    // --- Реалізація Чисто Віртуального Методу ---
    // Надаємо КОНКРЕТНУ реалізацію методу `getFillCharacter`, який був
    // оголошений як чисто віртуальний (`= 0`) у базовому класі `Tree`.
    // `override` - ключове слово (не обов'язкове, але дуже рекомендоване),
    // яке вказує компілятору, що ми *маємо намір* перевизначити віртуальний метод
    // з базового класу. Якщо такого методу в базі немає (наприклад, помилка в назві),
    // компілятор видасть помилку, що допомагає уникнути багів.
    // `const` - як і в базовому класі, обіцяємо не змінювати об'єкт.
    char getFillCharacter() const override {
        return '/'; // Ялинка заповнюється символом '/'
    }

    // --- Деструктор Нащадка ---
    // Хоча тут він порожній, він все одно буде викликаний *перед* деструктором
    // базового класу (`~Tree()`) завдяки віртуальності базового деструктора.
    // Якби тут були ресурси, специфічні для SpruceTree (наприклад, динамічно виділена пам'ять),
    // їх треба було б звільняти саме тут.
    ~SpruceTree() {
        // Можна додати вивід для дебагу: std::cout << "SpruceTree destructor called\n";
    }
    // Примітка: Ми НЕ перевизначаємо метод `draw()` тут, бо нас повністю
    // влаштовує реалізація з базового класу `Tree`, яка використовує НАШУ
    // реалізацію `getFillCharacter()` завдяки поліморфізму.
}; // Кінець опису класу SpruceTree


// --- КОНКРЕТНИЙ КЛАС-НАЩАДОК: Сосна ---
// Також успадковується від Tree, має схожу структуру, але іншу реалізацію `getFillCharacter`.
class PineTree : public Tree {
public:
    // Конструктор, що викликає конструктор базового класу
    explicit PineTree(int h) : Tree(h) {}

    // Власна реалізація для символу заповнення Сосни
    char getFillCharacter() const override {
        return '*'; // Сосна заповнюється символом '*'
    }

    // Деструктор (викликається перед ~Tree())
    ~PineTree() {}
}; // Кінець опису класу PineTree


// --- КОНКРЕТНИЙ КЛАС-НАЩАДОК: Дуб (?) ---
// Ще один нащадок Tree з унікальним символом заповнення.
class OakTree : public Tree {
public:
    // Конструктор, що викликає конструктор базового класу
    explicit OakTree(int h) : Tree(h) {}

    // Власна реалізація для символу заповнення Дуба
    char getFillCharacter() const override {
        return '+'; // Дуб заповнюється символом '+'
    }

    // Деструктор (викликається перед ~Tree())
    ~OakTree() {}
}; // Кінець опису класу OakTree


// --- Функція для безпечного отримання цілого числа (залишаємо для надійності) ---
int getIntegerInput(const std::string& prompt) {
    int value;
    while (true) {
        std::cout << prompt;
        std::cin >> value;
        if (std::cin.good()) {
            char remaining = std::cin.peek();
            if (remaining == '\n' || remaining == ' ') {
                 std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
                 return value;
            }
        }
        std::cout << "Помилка: Будь ласка, введіть тільки ціле число.\n";
        std::cin.clear();
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    }
}

// --- Функція для отримання позитивної висоти (залишаємо для надійності) ---
int getPositiveHeightInput(const std::string& treeName) {
     int height;
     while(true) {
        height = getIntegerInput("Введіть бажану висоту для '" + treeName + "' (> 0): ");
        if (height > 0) {
            return height;
        }
        std::cout << "Помилка: Висота повинна бути більшою за 0.\n";
     }
}


// --- Головна функція програми ---
int main() {
    std::cout << "--- Вічний Малювальник Дерев ---\n";
    std::cout << "(Натисніть Ctrl+C для виходу)\n\n";

    // Вічний цикл програми
    while (true) {
        int height; // Тимчасова змінна для зберігання введеної висоти
        Tree* treePtr = nullptr; // Вказівник на базовий клас Tree.
                                 // Може вказувати на об'єкт БУДЬ-ЯКОГО класу-нащадка (SpruceTree, PineTree, OakTree).
                                 // Ініціалізуємо nullptr для безпеки.

        // --- 1. Ялинка ---
        height = getPositiveHeightInput("Ялинка");    // Отримуємо висоту від користувача
        treePtr = new SpruceTree(height);             // Створюємо об'єкт SpruceTree в динамічній пам'яті (купі),
                                                      // конструктор SpruceTree(height) викликає Tree(height).
                                                      // Адреса створеного об'єкта зберігається у вказівнику treePtr (типу Tree*).
        std::cout << "\n--- Малюємо Ялинку (Висота: " << height << ") ---\n";
        treePtr->draw();                              // Викликаємо метод draw() ЧЕРЕЗ вказівник на базовий клас.
                                                      // Завдяки віртуальним функціям буде викликано Tree::draw(),
                                                      // а всередині нього - SpruceTree::getFillCharacter().
        delete treePtr;                               // Звільняємо пам'ять, виділену для об'єкта SpruceTree.
                                                      // Завдяки ВІРТУАЛЬНОМУ деструктору ~Tree(), буде коректно
                                                      // викликано спочатку ~SpruceTree(), а потім ~Tree().
        treePtr = nullptr;                            // Зануляємо вказівник після видалення (добра практика).
        std::cout << "-------------------------------------\n" << std::endl; // Роздільник

        // --- 2. Сосна (Логіка аналогічна до Ялинки) ---
        height = getPositiveHeightInput("Сосна");
        treePtr = new PineTree(height);              // Тепер treePtr вказує на об'єкт PineTree.
        std::cout << "\n--- Малюємо Сосну (Висота: " << height << ") ---\n";
        treePtr->draw();                             // Викликається Tree::draw(), всередині нього PineTree::getFillCharacter().
        delete treePtr;                              // Коректно викликаються ~PineTree(), потім ~Tree().
        treePtr = nullptr;
        std::cout << "-------------------------------------\n" << std::endl;

        // --- 3. Дуб (Логіка аналогічна до Ялинки) ---
        height = getPositiveHeightInput("Дуб");
        treePtr = new OakTree(height);               // Тепер treePtr вказує на об'єкт OakTree.
        std::cout << "\n--- Малюємо Дуб (Висота: " << height << ") ---\n";
        treePtr->draw();                             // Викликається Tree::draw(), всередині нього OakTree::getFillCharacter().
        delete treePtr;                              // Коректно викликаються ~OakTree(), потім ~Tree().
        treePtr = nullptr;
        std::cout << "-------------------------------------\n" << std::endl;

    } // Кінець вічного циклу while(true)

    // Через while(true) програма ніколи не досягне цього місця.
    // Вихід можливий тільки примусово (Ctrl+C).
    // return 0;
}
